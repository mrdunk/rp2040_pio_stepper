


; This program takes direction, number of steps and a step length as separate
; 32bit words on the FIFO.
; Provides no feedback.
; Confirmed working.

;.program step
;.side_set 1 opt
;
;.wrap_target
;    out x, 32     side 0
;    jmp !x direction_off
;    set pins, 1
;    jmp direction_done
;direction_off:
;    set pins, 0  [1]
;direction_done:
;
;    out isr, 32               ; Abuse isr register as a general purpose register.
;                              ; It will store the step length.
;
;    out y, 32                 ; y contains number of steps.
;
;    jmp step_entry
;
;step:
;    nop [5]       side 1      ; Pause for the same length of time as fetching data takes.
;    nop [6]       side 0
;step_entry:
;    mov x, isr    side 0      ; Restore the step length.
;pause_off:
;    jmp x-- pause_off
;
;    mov x, isr    side 1      ; Restore the step length. Turn step pin on
;pause_on:
;    jmp x-- pause_on
;
;    jmp y-- step              ; Do another step
;    nop [5]
;.wrap                         ; Go get more data.



;% c-sdk {
;// this is a raw helper function for use by the user which sets up the GPIO output, and configures the SM to output on a particular pin
;
;static inline void step_program_init(
;    PIO pio, uint sm, uint offset, uint pin_step, uint pin_direction
;) {
;   pio_sm_config config = step_program_get_default_config(offset);
;
;   pio_gpio_init(pio, pin_direction);
;   pio_sm_set_consecutive_pindirs(pio, sm, pin_direction, 1, true);
;   sm_config_set_set_pins(&config, pin_direction, 1);
;
;   pio_gpio_init(pio, pin_step);
;   pio_sm_set_consecutive_pindirs(pio, sm, pin_step, 1, true);
;   sm_config_set_sideset_pins(&config, pin_step);
;
;   //  	sm_config_set_in_shift(pio_sm_config*, shift_right, auto_push, push_threshold)
;   sm_config_set_out_shift(&config, 1, 1, 32);
;
;   // Join both FIFO registers.
;   sm_config_set_fifo_join(&config, PIO_FIFO_JOIN_TX);
;
;   pio_sm_init(pio, sm, offset, &config);
;}
;%}



;.program step_repeated
;.side_set 1 opt
;
;  set x, 0
;
;start:
;    mov y, STATUS   side 0    ; Determine if new data has arrived.
;    jmp !y, new_data
;    nop [5]
;data_acquired:
;
;    jmp !x, start             ; Special case. Treat step length of 0 as no steps
;                              ; until further data is received.
;
;    mov y, x                  ; Restore the step length.
;pause_off:
;    jmp y-- pause_off
;
;    mov y, x       side 1     ; Restore the step length. Turn step pin on.
;pause_on:
;    jmp y-- pause_on
;
;step_count:
;    mov y, ~isr               ; No increment available. Negate the value and decrease.
;    jmp y--, step_count_continue
;step_count_continue:
;    mov isr, ~y
;
;    jmp start
;
;new_data:
;    pull
;    out x, 32                 ; Store step length in X.
;    
;    push
;
;    set y, 0
;    mov isr, y
;
;    jmp data_acquired
;
;
;
;% c-sdk {
;
;// Setup helper function.
;static inline void step_repeated_program_init(PIO pio, uint sm, uint offset, uint pin_step) {
;  pio_sm_config config = step_repeated_program_get_default_config(offset);
;
;  sm_config_set_clkdiv(&config, 1.0);
;
;  // Setup GPIO
;  pio_gpio_init(pio, pin_step);
;  pio_sm_set_consecutive_pindirs(pio, sm, pin_step, 1, true);
;  sm_config_set_sideset_pins(&config, pin_step);
;
;  // Configure FIFOs.
;  // Out.
;  // sm_config_set_out_shift(pio_sm_config *c, bool shift_right, bool autopull, uint pull_threshold)
;  //sm_config_set_out_shift(&config, true, true, 32);
;  sm_config_set_out_shift(&config, true, false, 32);
;  // In.
;  // sm_config_set_in_shift(pio_sm_config *c, bool shift_right, bool autopush, uint push_threshold)
;  sm_config_set_in_shift(&config, true, false, 32);
;
;  // Enable feedback on input FIFO buffer contents.
;  sm_config_set_mov_status(&config, STATUS_TX_LESSTHAN, 1);
;
;  pio_sm_init(pio, sm, offset, &config);
;}
;
;%}




; This program expects the step and direction pin values to be encoded in the FIFO data.
; Packet format:
;   bit 0-27:  step length.
;   bit 28:    step pin value at start of step.
;   bit 29:     direction pin value at start of step.
;   bit 30:     step pin value for 2nd half of step.
;   bit 31:     direction pin value for 2nd half of step.
; Does not repeat. New data must be on FIFO for each step.
; Intended to be fed by DMA.
; Not tested.


;.program dma_step
;
;.wrap_target
;    out x,    28
;
;    mov y, x
;    out pins, 2
;pin_off:
;    jmp y-- pin_off
;
;    mov y, x
;    out pins, 2
;pin_on:
;    jmp y-- pin_on
;.wrap
;
;% c-sdk {
;// Helper function to configure `dma_step_program`.
;
;static inline void dma_step_program_init(PIO pio, uint sm, uint offset, uint pin) {
;  // Get default PIO config for modification.
;  pio_sm_config c = dma_step_program_get_default_config(offset);
;
;  // Setup pin and pin+1 to be accessible from the PIO
;  pio_gpio_init(pio, pin);
;  pio_gpio_init(pio, pin+1);
;
;  // Setup PIO SM to control pin and pin + 1
;  pio_sm_set_consecutive_pindirs(pio, sm, pin, 2, true);
;
;  // pin and pin + 1 are controlled by `out pins, ...` instructions
;  sm_config_set_out_pins(&c, pin, 2);
;
;  // Join both FIFO registers.
;  // sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_TX);
;
;  // Clock divider
;  // sm_config_set_clkdiv(&c, clk_div);
;
;  //	sm_config_set_in_shift(pio_sm_config*, shift_right, auto_push, push_threshold)
;  sm_config_set_out_shift(&c, true, true, 32);
;
;  pio_sm_init(pio, sm, offset, &c);
;  // Start PIO now.
;  pio_sm_set_enabled(pio, sm, true);
;}
;%}



.program step_pulse
.side_set 1 opt

  set x, 0

start:
    mov y, STATUS   side 0    ; Determine if new data has arrived.
    jmp !y, new_data
    nop [7]

data_acquired:
    jmp !x, start             ; Special case. Treat step length of 0 as no steps
                              ; until further data is received.

    mov y, x                  ; Restore the step length.
pause_off:
    jmp y-- pause_off

    mov y, x       side 1     ; Restore the step length. Turn step pin on.
pause_on:
    jmp y-- pause_on

    jmp start

new_data:
    pull
    out x, 32
    jmp !x direction_off
    set pins, 1
    jmp direction_done
direction_off:
    set pins, 0  [1]
direction_done:

    pull
    out x, 32                 ; Store step length in X.
    
    jmp data_acquired



% c-sdk {

// Setup helper function.
static inline void step_pulse_program_init(
    PIO pio, uint sm, uint offset, uint pin_step, uint pin_direction
) {
  pio_sm_config config = step_pulse_program_get_default_config(offset);

  sm_config_set_clkdiv(&config, 1.0);


  // Setup GPIO
  pio_gpio_init(pio, pin_step);
  pio_sm_set_consecutive_pindirs(pio, sm, pin_step, 1, true);
  sm_config_set_sideset_pins(&config, pin_step);

  pio_gpio_init(pio, pin_direction);
  pio_sm_set_consecutive_pindirs(pio, sm, pin_direction, 1, true);
  sm_config_set_set_pins(&config, pin_direction, 1);


  // Configure FIFOs.
  // Out.
  // sm_config_set_out_shift(pio_sm_config *c, bool shift_right, bool autopull, uint pull_threshold)
  sm_config_set_out_shift(&config, true, false, 32);


  // Enable feedback on input FIFO buffer contents.
  sm_config_set_mov_status(&config, STATUS_TX_LESSTHAN, 1);

  
  pio_sm_init(pio, sm, offset, &config);
}

%}




.program step_count
.side_set 1 opt

    pull
    out y, 32                 ; Initial position..

start:
    wait 0 pin 0
    wait 1 pin 0

    jmp pin step_increase

step_decrease:
    jmp y-- step_decrease_continue
step_decrease_continue:
    mov isr, y
    push noblock
    jmp start


step_increase:
    mov y, ~y
    jmp y--, step_increase_continue
step_increase_continue:
    mov y, ~y
    mov isr, y
    push noblock
    jmp start


% c-sdk {

// Setup helper function.
static inline void step_count_program_init(
    PIO pio, uint sm, uint offset, uint pin_step, uint pin_direction
) {
  pio_sm_config config = step_count_program_get_default_config(offset);

  sm_config_set_clkdiv(&config, 1.0);


  // Setup GPIO
  //pio_gpio_init(pio, pin_step);
  //pio_gpio_init(pio, pin_direction);
  pio_sm_set_consecutive_pindirs(pio, sm, pin_step, 2, false);
  //sm_config_set_in_pins(&config, pin_step);
  //sm_config_set_in_pins(&config, pin_direction);

  sm_config_set_in_pins(&config, pin_step);   // for WAIT, IN
  sm_config_set_jmp_pin(&config, pin_direction);   // for JMP


  // Configure FIFOs.
  // Out.
  // sm_config_set_out_shift(pio_sm_config *c, bool shift_right, bool autopull, uint pull_threshold)
  sm_config_set_out_shift(&config, true, true, 32);

  // In.
  // sm_config_set_in_shift(pio_sm_config *c, bool shift_right, bool autopush, uint push_threshold)
  sm_config_set_in_shift(&config, true, false, 32);


  // Clear interrupts.
  //pio_interrupt_clear(pio, sm);

  pio_sm_init(pio, sm, offset, &config);
}

%}




